<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Premium 3D Jewelry Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            touch-action: pan-x pan-y;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 15px 25px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        .title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
            font-family: 'Georgia', serif;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 0.9rem;
            color: #e6e6e6;
            min-width: 80px;
            font-weight: 500;
        }

        select, button {
            background: rgba(255, 215, 0, 0.15);
            border: 2px solid #ffd700;
            color: #fff;
            padding: 10px 16px;
            border-radius: 10px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Georgia', serif;
            font-weight: 500;
        }

        select:hover, button:hover {
            background: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
            transform: translateY(-2px);
        }

        select:focus, button:focus {
            outline: none;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.7);
        }

        .zoom-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .zoom-btn {
            width: 65px;
            height: 65px;
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.25);
            border: 3px solid #ffd700;
            color: #fff;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .zoom-btn:hover {
            background: rgba(255, 215, 0, 0.5);
            transform: scale(1.15);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
        }

        .info-panel {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            padding: 25px;
            border-radius: 20px;
            border: 2px solid #ffd700;
            max-width: 350px;
            font-size: 0.95rem;
            line-height: 1.6;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(15px);
        }

        .info-title {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 12px;
            font-size: 1.1rem;
            text-shadow: 0 0 10px #ffd700;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #ffd700;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 5px solid rgba(255, 215, 0, 0.3);
            border-top: 5px solid #ffd700;
            border-radius: 50%;
            animation: spin 1.2s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #ffd700;
            font-size: 1.2rem;
            font-weight: 500;
            text-shadow: 0 0 15px #ffd700;
        }

        .quality-indicator {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #ffd700;
            font-size: 0.8rem;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .ui-overlay {
                padding: 12px 20px;
                flex-direction: column;
                align-items: stretch;
            }

            .title {
                font-size: 1.2rem;
                text-align: center;
            }

            .controls {
                justify-content: center;
                gap: 10px;
            }

            .control-group {
                flex-direction: column;
                align-items: center;
                min-width: 100px;
            }

            .control-label {
                font-size: 0.8rem;
                min-width: auto;
                text-align: center;
            }

            select, button {
                padding: 12px 16px;
                font-size: 0.9rem;
                min-width: 90px;
            }

            .zoom-controls {
                bottom: 140px;
                right: 20px;
            }

            .zoom-btn {
                width: 55px;
                height: 55px;
                font-size: 1.7rem;
            }

            .info-panel {
                bottom: 20px;
                left: 20px;
                right: 20px;
                max-width: none;
                font-size: 0.85rem;
                padding: 20px;
            }

            .quality-indicator {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading Premium Gem Engine...</div>
        </div>

        <div class="ui-overlay">
            <div class="title">💎 Premium Gem Viewer 💎</div>
            <div class="controls">
                <div class="control-group">
                    <label class="control-label">Cut Style:</label>
                    <select id="objectSelect">
                        <option value="brilliant">Brilliant Round</option>
                        <option value="emerald">Emerald Cut</option>
                        <option value="princess">Princess Cut</option>
                        <option value="oval">Oval Cut</option>
                        <option value="pear">Pear Cut</option>
                        <option value="marquise">Marquise Cut</option>
                        <option value="cushion">Cushion Cut</option>
                        <option value="asscher">Asscher Cut</option>
                        <option value="radiant">Radiant Cut</option>
                        <option value="heart">Heart Cut</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">Gemstone:</label>
                    <select id="materialSelect">
                        <option value="diamond">Diamond</option>
                        <option value="ruby">Ruby</option>
                        <option value="sapphire">Sapphire</option>
                        <option value="emerald">Emerald</option>
                        <option value="crystal">Crystal</option>
                        <option value="opal">Opal</option>
                        <option value="topaz">Topaz</option>
                        <option value="amethyst">Amethyst</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">Animation:</label>
                    <button id="animateBtn">▶ Rotate</button>
                </div>
                <div class="control-group">
                    <label class="control-label">Reset:</label>
                    <button id="resetBtn">↻ Reset</button>
                </div>
            </div>
        </div>

        <div class="zoom-controls">
            <button class="zoom-btn" id="zoomIn">+</button>
            <button class="zoom-btn" id="zoomOut">−</button>
        </div>

        <div class="quality-indicator">
            <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">Rendering Quality</div>
            <div>✓ Physical Materials</div>
            <div>✓ HDRI Lighting</div>
            <div>✓ Bloom Effects</div>
            <div>✓ Real Refraction</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Current Gem: Brilliant Cut Diamond</div>
            <div id="objectInfo">
                The classic round brilliant cut with 57 or 58 facets arranged in precise mathematical proportions to maximize light return. Developed over centuries, this cut represents the perfect balance of fire, brilliance, and scintillation.
            </div>
            <br>
            <div style="color: #ccc; font-size: 0.8rem;">
                🖱️ Drag to rotate • 🔍 Scroll to zoom<br>
                📱 Touch controls supported<br>
                ✨ Real-time ray tracing enabled
            </div>
        </div>

        <canvas id="canvas"></canvas>
    </div>

    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js"></script>
    <!-- Post-processing -->
    <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/OutputPass.js"></script>
    <!-- Controls -->
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Three.js setup
        let scene, camera, renderer, currentObject, controls, composer;
        let isAnimating = false;
        let environmentTexture = null;

        // Gem specifications with realistic IOR values
        const gemSpecs = {
            diamond: { color: 0xffffff, ior: 2.417, dispersion: 0.044, transparency: 0.95, roughness: 0.0 },
            ruby: { color: 0xdc143c, ior: 1.76, dispersion: 0.018, transparency: 0.85, roughness: 0.05 },
            sapphire: { color: 0x082567, ior: 1.76, dispersion: 0.018, transparency: 0.85, roughness: 0.05 },
            emerald: { color: 0x50c878, ior: 1.57, dispersion: 0.014, transparency: 0.80, roughness: 0.08 },
            crystal: { color: 0xf8f8ff, ior: 1.544, dispersion: 0.009, transparency: 0.95, roughness: 0.0 },
            opal: { color: 0xffffff, ior: 1.45, dispersion: 0.013, transparency: 0.70, roughness: 0.15 },
            topaz: { color: 0xffc87c, ior: 1.63, dispersion: 0.014, transparency: 0.88, roughness: 0.02 },
            amethyst: { color: 0x9966cc, ior: 1.544, dispersion: 0.013, transparency: 0.85, roughness: 0.03 }
        };

        // Detailed gem information
        const jewelryInfo = {
            brilliant: "The round brilliant cut features 57 or 58 facets arranged in precise mathematical proportions to maximize light return. Developed over centuries, this cut represents the perfect balance of fire, brilliance, and scintillation.",
            emerald: "The emerald cut showcases clarity and color through its rectangular step-cut faceting. With its large table and open facets, this cut emphasizes the gem's natural beauty and internal characteristics.",
            princess: "A modern square brilliant cut that combines contemporary aesthetics with maximum fire. The princess cut's pointed corners and brilliant-style faceting create exceptional sparkle in a geometric form.",
            oval: "An elongated brilliant cut that maximizes carat weight while maintaining exceptional brilliance. The oval shape creates an elegant silhouette that flatters the finger with its graceful proportions.",
            pear: "Also known as the teardrop cut, this unique shape combines the brilliance of a round cut with the elegance of a marquise. Perfect symmetry is crucial for this sophisticated asymmetrical design.",
            marquise: "A boat-shaped cut that creates the illusion of greater size while maximizing carat weight. Named after the Marquise de Pompadour, this cut requires exceptional skill to achieve perfect symmetry.",
            cushion: "Combining old-world charm with modern brilliance, the cushion cut features rounded corners and larger facets. This vintage-inspired cut offers exceptional fire and a romantic, soft appearance.",
            asscher: "A square step-cut with cropped corners, similar to the emerald cut but in a square form. Known for its deep pavilion and high crown, creating a 'hall of mirrors' effect with exceptional brilliance.",
            radiant: "A rectangular cut with brilliant-style faceting that combines the elegance of emerald cut with the fire of round brilliant. The trimmed corners provide durability while maximizing sparkle.",
            heart: "The ultimate symbol of love, the heart shape requires exceptional cutting skill to achieve perfect symmetry. This modified brilliant cut maintains maximum fire while creating an unmistakable romantic silhouette."
        };

        async function init() {
            try {
                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);

                // Camera setup with better FOV for jewelry
                camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 8);

                // Enhanced renderer setup
                renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'),
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Enable advanced features
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                renderer.physicallyCorrectLights = true;
                renderer.outputColorSpace = THREE.SRGBColorSpace;

                // Setup controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 3;
                controls.maxDistance = 20;
                controls.enablePan = false;

                // Load studio environment
                loadEnvironment();

                // Setup post-processing
                setupPostProcessing();

                // Create initial jewelry
                createJewelry('brilliant', 'diamond');

                // Setup event listeners
                setupEventListeners();

                // Start render loop
                animate();

                // Hide loading screen
                document.getElementById('loading').style.display = 'none';

            } catch (error) {
                console.error('Initialization failed:', error);
                document.querySelector('.loading-text').textContent = 'Loading failed. Starting with basic setup...';
                
                // Fallback initialization
                setupFallbackLighting();
                setupPostProcessing();
                createJewelry('brilliant', 'diamond');
                setupEventListeners();
                animate();
                
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            }
        }

        function createStudioEnvironment() {
            // Create a high-quality procedural studio environment
            const size = 1024;
            const data = new Float32Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const index = (i * size + j) * 4;
                    
                    // Convert to spherical coordinates
                    const u = i / size;
                    const v = j / size;
                    const theta = u * Math.PI * 2; // 0 to 2π
                    const phi = v * Math.PI;       // 0 to π
                    
                    // Create studio lighting pattern
                    let intensity = 0.1; // Base ambient
                    
                    // Key light (main studio light)
                    const keyLightDir = { theta: Math.PI * 0.3, phi: Math.PI * 0.4 };
                    const keyDist = Math.acos(
                        Math.sin(phi) * Math.sin(keyLightDir.phi) * Math.cos(theta - keyLightDir.theta) +
                        Math.cos(phi) * Math.cos(keyLightDir.phi)
                    );
                    if (keyDist < 0.8) {
                        intensity += 3.0 * Math.exp(-keyDist * keyDist * 8);
                    }
                    
                    // Fill light (softer, opposite side)
                    const fillLightDir = { theta: Math.PI * 1.7, phi: Math.PI * 0.6 };
                    const fillDist = Math.acos(
                        Math.sin(phi) * Math.sin(fillLightDir.phi) * Math.cos(theta - fillLightDir.theta) +
                        Math.cos(phi) * Math.cos(fillLightDir.phi)
                    );
                    if (fillDist < 1.0) {
                        intensity += 1.5 * Math.exp(-fillDist * fillDist * 3);
                    }
                    
                    // Rim lights (for edge definition)
                    const rimLight1Dir = { theta: Math.PI * 0.1, phi: Math.PI * 0.5 };
                    const rim1Dist = Math.acos(
                        Math.sin(phi) * Math.sin(rimLight1Dir.phi) * Math.cos(theta - rimLight1Dir.theta) +
                        Math.cos(phi) * Math.cos(rimLight1Dir.phi)
                    );
                    if (rim1Dist < 0.6) {
                        intensity += 2.0 * Math.exp(-rim1Dist * rim1Dist * 12);
                    }
                    
                    const rimLight2Dir = { theta: Math.PI * 1.9, phi: Math.PI * 0.5 };
                    const rim2Dist = Math.acos(
                        Math.sin(phi) * Math.sin(rimLight2Dir.phi) * Math.cos(theta - rimLight2Dir.theta) +
                        Math.cos(phi) * Math.cos(rimLight2Dir.phi)
                    );
                    if (rim2Dist < 0.6) {
                        intensity += 1.8 * Math.exp(-rim2Dist * rim2Dist * 12);
                    }
                    
                    // Ground reflection (subtle)
                    if (phi > Math.PI * 0.8) {
                        intensity += 0.3 * (1 - Math.abs(theta - Math.PI) / Math.PI);
                    }
                    
                    // Color temperature variation
                    const warmth = 0.05 + 0.1 * Math.sin(theta + phi);
                    const coolness = 0.05 + 0.08 * Math.cos(theta * 2);
                    
                    // Apply color and intensity
                    data[index] = intensity * (1.0 + warmth);           // R (warm)
                    data[index + 1] = intensity * 1.0;                  // G (neutral)
                    data[index + 2] = intensity * (1.0 + coolness);     // B (cool)
                    data[index + 3] = 1.0;                              // A
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.needsUpdate = true;
            
            return texture;
        }

        function loadEnvironment() {
            // Create studio environment texture
            environmentTexture = createStudioEnvironment();
            
            // Set as scene environment and background
            scene.environment = environmentTexture;
            
            // Create a subtle gradient background instead of full HDRI
            const backgroundGeometry = new THREE.SphereGeometry(50, 32, 16);
            const backgroundMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0a0a0a) },
                    bottomColor: { value: new THREE.Color(0x000000) },
                    offset: { value: 0.3 },
                    exponent: { value: 0.8 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            const backgroundMesh = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
            scene.add(backgroundMesh);
            
            console.log('Studio environment loaded successfully');
        }

        function setupFallbackLighting() {
            // Enhanced lighting setup for jewelry rendering
            scene.add(new THREE.AmbientLight(0x404040, 0.2));

            // Key light
            const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
            keyLight.position.set(10, 10, 5);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.5;
            keyLight.shadow.camera.far = 500;
            scene.add(keyLight);

            // Fill lights for even illumination
            const fillLight1 = new THREE.PointLight(0xffd700, 1.5, 100);
            fillLight1.position.set(-8, 8, 8);
            scene.add(fillLight1);

            const fillLight2 = new THREE.PointLight(0xe6e6fa, 1.2, 100);
            fillLight2.position.set(8, -8, 8);
            scene.add(fillLight2);

            // Rim lights for edge definition
            const rimLight1 = new THREE.SpotLight(0xffffff, 1.0, 100, Math.PI / 6);
            rimLight1.position.set(-10, 0, -10);
            rimLight1.target.position.set(0, 0, 0);
            scene.add(rimLight1);
            scene.add(rimLight1.target);

            const rimLight2 = new THREE.SpotLight(0xffd700, 0.8, 100, Math.PI / 6);
            rimLight2.position.set(10, 0, -10);
            rimLight2.target.position.set(0, 0, 0);
            scene.add(rimLight2);
            scene.add(rimLight2.target);
        }

        function setupPostProcessing() {
            composer = new THREE.EffectComposer(renderer);

            // Base render pass
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Bloom pass for gem sparkle
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.8,  // strength
                0.4,  // radius  
                0.85  // threshold
            );
            composer.addPass(bloomPass);

            // Output pass
            const outputPass = new THREE.OutputPass();
            composer.addPass(outputPass);
        }

        function createJewelry(cutType, gemType) {
            // Remove existing object
            if (currentObject) {
                scene.remove(currentObject);
            }

            let geometry;
            
            switch(cutType) {
                case 'brilliant':
                    geometry = createBrilliantCut();
                    break;
                case 'emerald':
                    geometry = createEmeraldCut();
                    break;
                case 'princess':
                    geometry = createPrincessCut();
                    break;
                case 'oval':
                    geometry = createOvalCut();
                    break;
                case 'pear':
                    geometry = createPearCut();
                    break;
                case 'marquise':
                    geometry = createMarquiseCut();
                    break;
                case 'cushion':
                    geometry = createCushionCut();
                    break;
                case 'asscher':
                    geometry = createAsscherCut();
                    break;
                case 'radiant':
                    geometry = createRadiantCut();
                    break;
                case 'heart':
                    geometry = createHeartCut();
                    break;
                default:
                    geometry = createBrilliantCut();
            }

            const material = createRealisticGemMaterial(gemType);
            currentObject = new THREE.Mesh(geometry, material);
            currentObject.castShadow = true;
            currentObject.receiveShadow = true;
            
            scene.add(currentObject);

            // Update info panel
            updateInfoPanel(cutType, gemType);
        }

        function createRealisticGemMaterial(gemType) {
            const spec = gemSpecs[gemType] || gemSpecs.diamond;
            
            const material = new THREE.MeshPhysicalMaterial({
                color: new THREE.Color(spec.color),
                
                // Transparency settings
                transparent: true,
                opacity: 1.0,
                transmission: spec.transparency,
                thickness: 2.0,
                
                // Surface properties  
                roughness: spec.roughness,
                metalness: 0.0,
                
                // Reflection properties
                reflectivity: 1.0,
                ior: spec.ior,
                
                // Clearcoat for extra gloss
                clearcoat: 1.0,
                clearcoatRoughness: 0.01,
                
                // Advanced properties
                sheen: 1.0,
                sheenRoughness: 0.1,
                sheenColor: new THREE.Color(spec.color).multiplyScalar(0.1),
                
                // Iridescence for opal
                iridescence: gemType === 'opal' ? 1.0 : 0.0,
                iridescenceIOR: 1.3,
                iridescenceThicknessRange: [100, 800],
                
                // Environment map intensity
                envMapIntensity: 2.0,
                
                // Advanced material properties
                attenuationColor: new THREE.Color(spec.color),
                attenuationDistance: 1.0,
                
                // Enable physical correctness
                side: THREE.DoubleSide
            });

            // Add dispersion effect for diamonds
            if (gemType === 'diamond') {
                material.dispersion = 0.05;
            }

            return material;
        }

        function createBrilliantCut() {
            // Create a more accurate brilliant cut with proper crown and pavilion
            const crownGeometry = new THREE.ConeGeometry(2.2, 1.0, 32, 1, false, 0, Math.PI * 2);
            const pavilionGeometry = new THREE.ConeGeometry(2.2, 2.5, 32, 1, false, 0, Math.PI * 2);
            
            // Position pavilion below crown
            pavilionGeometry.rotateX(Math.PI);
            pavilionGeometry.translate(0, -1.0, 0);
            
            // Merge geometries
            const mergedGeometry = new THREE.BufferGeometry();
            const crownPositions = crownGeometry.attributes.position.array;
            const pavilionPositions = pavilionGeometry.attributes.position.array;
            
            const positions = new Float32Array(crownPositions.length + pavilionPositions.length);
            positions.set(crownPositions, 0);
            positions.set(pavilionPositions, crownPositions.length);
            
            mergedGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Create proper faceting
            const positionAttribute = mergedGeometry.attributes.position;
            for (let i = 0; i < positionAttribute.count; i++) {
                let x = positionAttribute.getX(i);
                let y = positionAttribute.getY(i);
                let z = positionAttribute.getZ(i);
                
                const radius = Math.sqrt(x * x + z * z);
                const angle = Math.atan2(z, x);
                
                // Create facets (main facets + star facets)
                const mainFacets = 8;
                const starFacets = 16;
                
                if (y > 0) { // Crown
                    const facetAngle = Math.floor(angle / (Math.PI * 2 / starFacets)) * (Math.PI * 2 / starFacets);
                    const facetOffset = 0.95 + 0.05 * Math.cos(facetAngle * starFacets);
                    x = Math.cos(angle) * radius * facetOffset;
                    z = Math.sin(angle) * radius * facetOffset;
                } else { // Pavilion
                    const facetAngle = Math.floor(angle / (Math.PI * 2 / mainFacets)) * (Math.PI * 2 / mainFacets);
                    const facetOffset = 0.98 + 0.02 * Math.cos(facetAngle * mainFacets);
                    x = Math.cos(angle) * radius * facetOffset;
                    z = Math.sin(angle) * radius * facetOffset;
                }
                
                positionAttribute.setXYZ(i, x, y, z);
            }
            
            mergedGeometry.computeVertexNormals();
            return mergedGeometry;
        }

        function createEmeraldCut() {
            // Precise emerald cut with step facets
            const geometry = new THREE.BoxGeometry(3.0, 2.0, 4.0, 8, 4, 12);
            const position = geometry.attributes.position;
            
            for (let i = 0; i < position.count; i++) {
                let x = position.getX(i);
                let y = position.getY(i);
                let z = position.getZ(i);
                
                // Create beveled corners (hallmark of emerald cut)
                const cornerSize = 0.4;
                const xAbs = Math.abs(x);
                const zAbs = Math.abs(z);
                
                if (xAbs > 1.5 - cornerSize && zAbs > 2.0 - cornerSize) {
                    const cornerX = xAbs - (1.5 - cornerSize);
                    const cornerZ = zAbs - (2.0 - cornerSize);
                    x = Math.sign(x) * (1.5 - cornerSize + cornerX * 0.7);
                    z = Math.sign(z) * (2.0 - cornerSize + cornerZ * 0.7);
                }
                
                // Create step cuts
                const stepCount = 3;
                const yStep = Math.floor((y + 1.0) / (2.0 / stepCount));
                const stepIndent = yStep * 0.02;
                
                if (Math.abs(y) < 0.8) {
                    x *= (1 - stepIndent);
                    z *= (1 - stepIndent);
                }
                
                position.setXYZ(i, x, y, z);
            }
            
            geometry.computeVertexNormals();
            return geometry;
        }

        function createPrincessCut() {
            // Modern square brilliant cut
            const geometry = new THREE.BoxGeometry(2.8, 2.8, 2.0, 16, 16, 8);
            const position = geometry.attributes.position;
            
            for (let i = 0; i < position.count; i++) {
                let x = position.getX(i);
                let y = position.getY(i);
                let z = position.getZ(i);
                
                // Create pyramid crown
                if (z > 0) {
                    const factor = 1 - (z / 1.0) * 0.4;
                    x *= factor;
                    y *= factor;
                }
                
                // Add brilliant-style faceting
                const facetSize = 0.2;
                const xFacet = Math.floor(x / facetSize) * facetSize + facetSize * 0.5;
                const yFacet = Math.floor(y / facetSize) * facetSize + facetSize * 0.5;
                
                const facetNoise = 0.98 + 0.02 * Math.sin(xFacet * 20) * Math.sin(yFacet * 20);
                x *= facetNoise;
                y *= facetNoise;
                
                position.setXYZ(i, x, y, z);
            }
            
            geometry.computeVertexNormals();
            return geometry;
        }

        function createOvalCut() {
            // Oval brilliant with proper proportions
            const geometry = new THREE.SphereGeometry(2.0, 64, 32);
            const position = geometry.attributes.position;
            
            for (let i = 0; i < position.count; i++) {
                let x = position.getX(i);
                let y = position.getY(i);
                let z = position.getZ(i);
                
                // Create oval shape (1.6:1 ratio)
                z *= 1.6;
                
                // Add brilliant faceting
                const theta = Math.atan2(y, x);
                const phi = Math.atan2(Math.sqrt(x*x + y*y), z);
                
                const facetCount = 32;
                const facetTheta = Math.floor(theta / (Math.PI * 2 / facetCount)) * (Math.PI * 2 / facetCount);
                const facetPhi = Math.floor(phi / (Math.PI / 16)) * (Math.PI / 16);
                
                const facetNoise = 0.97 + 0.03 * (Math.cos(facetTheta * facetCount) + Math.cos(facetPhi * 16));
                
                x *= facetNoise;
                y *= facetNoise; 
                z *= facetNoise;
                
                position.setXYZ(i, x, y, z);
            }
            
            geometry.computeVertexNormals();
            return geometry;
        }

        function createPearCut() {
            // Pear-shaped brilliant
            const geometry = new THREE.SphereGeometry(2.0, 64, 32);
            const position = geometry.attributes.position;
            
            for (let i = 0; i < position.count; i++) {
                let x = position.getX(i);
                let y = position.getY(i);
                let z = position.getZ(i);
                
                // Create pear shape
                const r = Math.sqrt(x*x + y*y + z*z);
                const zNorm = z / r;
                
                // Elongate and taper
                z *= 1.5;
                if (z > 0) {
                    const taperFactor = 1 - (z / 3.0) * 0.7;
                    x *= taperFactor;
                    y *= taperFactor;
                }
                
                // Add faceting with pear-specific pattern
                const angle = Math.atan2(y, x);
                const facets = z > 0 ? 16 : 32; // Fewer facets at the point
                const facetAngle = Math.floor(angle / (Math.PI * 2 / facets)) * (Math.PI * 2 / facets);
                const facetNoise = 0.96 + 0.04 * Math.cos(facetAngle * facets);
                
                x *= facetNoise;
                y *= facetNoise;
                z *= facetNoise;
                
                position.setXYZ(i, x, y, z);
            }
            
            geometry.computeVertexNormals();
            return geometry;
        }

        function createMarquiseCut() {
            // Marquise (navette) cut with pointed ends
            const geometry = new THREE.SphereGeometry(1.8, 64, 32);
            const position = geometry.attributes.position;
            
            for (let i = 0; i < position.count; i++) {
                let x = position.getX(i);
                let y = position.getY(i);
                let z = position.getZ(i);
                
                // Elongate significantly
                z *= 2.2;
                
                // Create pointed ends
                const zAbs = Math.abs(z);
                if (zAbs > 2.5) {
                    const pointFactor = Math.max(0.05, 1 - (zAbs - 2.5) * 3);
                    x *= pointFactor;
                    y *= pointFactor;
                } else if (zAbs > 2.0) {
                    const taperFactor = 1 - (zAbs - 2.0) * 0.6;
                    x *= taperFactor;
                    y *= taperFactor;
                }
                
                // Brilliant faceting adapted for marquise
                const angle = Math.atan2(y, x);
                const facetCount = 24;
                const facetAngle = Math.floor(angle / (Math.PI * 2 / facetCount)) * (Math.PI * 2 / facetCount);
                const facetNoise = 0.97 + 0.03 * Math.cos(facetAngle * facetCount);
                
                x *= facetNoise;
                y *= facetNoise;
                z *= facetNoise;
                
                position.setXYZ(i, x, y, z);
            }
            
            geometry.computeVertexNormals();
            return geometry;
        }

        function createCushionCut() {
            // Cushion cut with rounded corners
            const geometry = new THREE.BoxGeometry(2.6, 2.6, 2.2, 24, 24, 16);
            const position = geometry.attributes.position;
            
            for (let i = 0; i < position.count; i++) {
                let x = position.getX(i);
                let y = position.getY(i);
                let z = position.getZ(i);
                
                // Round the corners significantly
                const cornerRadius = 0.5;
                const xAbs = Math.abs(x);
                const yAbs = Math.abs(y);
                
                if (xAbs > 1.3 - cornerRadius && yAbs > 1.3 - cornerRadius) {
                    const cornerX = xAbs - (1.3 - cornerRadius);
                    const cornerY = yAbs - (1.3 - cornerRadius);
                    const cornerDist = Math.sqrt(cornerX * cornerX + cornerY * cornerY);
                    
                    if (cornerDist > 0) {
                        const scale = Math.min(1.0, cornerRadius / cornerDist);
                        x = Math.sign(x) * ((1.3 - cornerRadius) + cornerX * scale);
                        y = Math.sign(y) * ((1.3 - cornerRadius) + cornerY * scale);
                    }
                }
                
                // Modified brilliant faceting for cushion
                const facetX = Math.floor(x / 0.2) * 0.2;
                const facetY = Math.floor(y / 0.2) * 0.2;
                const facetNoise = 0.96 + 0.04 * Math.sin(facetX * 15) * Math.sin(facetY * 15);
                
                x *= facetNoise;
                y *= facetNoise;
                
                position.setXYZ(i, x, y, z);
            }
            
            geometry.computeVertexNormals();
            return geometry;
        }

        function createAsscherCut() {
            // Square step cut similar to emerald
            const geometry = new THREE.BoxGeometry(2.8, 2.8, 2.4, 16, 16, 12);
            const position = geometry.attributes.position;
            
            for (let i = 0; i < position.count; i++) {
                let x = position.getX(i);
                let y = position.getY(i);
                let z = position.getZ(i);
                
                // Cut corners at precise angles
                const cornerSize = 0.35;
                const xAbs = Math.abs(x);
                const yAbs = Math.abs(y);
                
                if (xAbs > 1.4 - cornerSize && yAbs > 1.4 - cornerSize) {
                    const cutX = xAbs - (1.4 - cornerSize);
                    const cutY = yAbs - (1.4 - cornerSize);
                    if (cutX + cutY > cornerSize) {
                        const reduction = (cutX + cutY - cornerSize) / 2;
                        x = Math.sign(x) * (xAbs - reduction);
                        y = Math.sign(y) * (yAbs - reduction);
                    }
                }
                
                // Step cut faceting
                const stepCount = 4;
                const zStep = Math.floor((z + 1.2) / (2.4 / stepCount));
                const stepIndent = zStep * 0.03;
                
                if (Math.abs(z) < 1.0) {
                    x *= (1 - stepIndent);
                    y *= (1 - stepIndent);
                }
                
                position.setXYZ(i, x, y, z);
            }
            
            geometry.computeVertexNormals();
            return geometry;
        }

        function createRadiantCut() {
            // Rectangular brilliant with cut corners
            const geometry = new THREE.BoxGeometry(2.8, 2.0, 3.2, 20, 14, 24);
            const position = geometry.attributes.position;
            
            for (let i = 0; i < position.count; i++) {
                let x = position.getX(i);
                let y = position.getY(i);
                let z = position.getZ(i);
                
                // Cut corners
                const cornerCut = 0.3;
                const xAbs = Math.abs(x);
                const zAbs = Math.abs(z);
                
                if (xAbs > 1.4 - cornerCut && zAbs > 1.6 - cornerCut) {
                    x *= 0.85;
                    z *= 0.85;
                }
                
                // Brilliant-style faceting
                const facetScale = 0.15;
                const facetX = Math.floor(x / facetScale) * facetScale;
                const facetZ = Math.floor(z / facetScale) * facetScale;
                
                const brilliantNoise = 0.94 + 0.06 * (
                    Math.cos(facetX * 25) * Math.cos(facetZ * 20) +
                    Math.sin(facetX * 40) * Math.sin(facetZ * 35)
                );
                
                x *= brilliantNoise;
                y *= brilliantNoise;
                z *= brilliantNoise;
                
                position.setXYZ(i, x, y, z);
            }
            
            geometry.computeVertexNormals();
            return geometry;
        }

        function createHeartCut() {
            // Heart-shaped brilliant cut
            const geometry = new THREE.SphereGeometry(1.8, 64, 32);
            const position = geometry.attributes.position;
            
            for (let i = 0; i < position.count; i++) {
                let x = position.getX(i);
                let y = position.getY(i);
                let z = position.getZ(i);
                
                // Create heart shape using parametric equations
                const r = Math.sqrt(x*x + z*z);
                const theta = Math.atan2(z, x);
                
                // Heart curve (modified for 3D)
                const heartScale = 0.6;
                const heartX = heartScale * (16 * Math.pow(Math.sin(theta), 3));
                const heartZ = heartScale * (13 * Math.cos(theta) - 5 * Math.cos(2*theta) - 2 * Math.cos(3*theta) - Math.cos(4*theta));
                
                // Interpolate between sphere and heart shape
                const blend = Math.min(1.0, r / 1.5);
                x = (1 - blend) * heartX + blend * x;
                z = (1 - blend) * heartZ + blend * z;
                
                // Scale to fit
                const scale = 0.12;
                x *= scale * (r / 1.8);
                z *= scale * (r / 1.8);
                
                // Add brilliant faceting
                const facetTheta = Math.floor(theta / (Math.PI / 12)) * (Math.PI / 12);
                const facetNoise = 0.95 + 0.05 * Math.cos(facetTheta * 12);
                
                x *= facetNoise;
                y *= facetNoise;
                z *= facetNoise;
                
                position.setXYZ(i, x, y, z);
            }
            
            geometry.computeVertexNormals();
            return geometry;
        }

        function setupEventListeners() {
            // Object selection
            document.getElementById('objectSelect').addEventListener('change', (e) => {
                const gemType = document.getElementById('materialSelect').value;
                createJewelry(e.target.value, gemType);
            });

            // Material selection
            document.getElementById('materialSelect').addEventListener('change', (e) => {
                const cutType = document.getElementById('objectSelect').value;
                createJewelry(cutType, e.target.value);
            });

            // Animation toggle
            document.getElementById('animateBtn').addEventListener('click', () => {
                isAnimating = !isAnimating;
                document.getElementById('animateBtn').textContent = isAnimating ? '⏸ Pause' : '▶ Rotate';
                controls.autoRotate = isAnimating;
                controls.autoRotateSpeed = 0.5;
            });

            // Reset button
            document.getElementById('resetBtn').addEventListener('click', () => {
                if (currentObject) {
                    currentObject.rotation.set(0, 0, 0);
                }
                controls.reset();
            });

            // Zoom controls
            document.getElementById('zoomIn').addEventListener('click', () => {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.addScaledVector(direction, 1);
                controls.update();
            });

            document.getElementById('zoomOut').addEventListener('click', () => {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.addScaledVector(direction, -1);
                controls.update();
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function updateInfoPanel(cutType, gemType) {
            const titleElement = document.querySelector('.info-title');
            const infoElement = document.getElementById('objectInfo');
            
            const cutName = cutType.charAt(0).toUpperCase() + cutType.slice(1);
            const gemName = gemType.charAt(0).toUpperCase() + gemType.slice(1);
            
            titleElement.textContent = `Current Gem: ${cutName} Cut ${gemName}`;
            infoElement.textContent = jewelryInfo[cutType] || "A magnificent gemstone showcasing exceptional cutting artistry and optical properties.";
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update controls
            controls.update();

            // Render with post-processing
            composer.render();
        }

        // Initialize when page loads
        window.addEventListener('load', init);

        // Performance monitoring
        let frameCount = 0;
        let lastTime = performance.now();
        
        setInterval(() => {
            const now = performance.now();
            const fps = Math.round(frameCount * 1000 / (now - lastTime));
            frameCount = 0;
            lastTime = now;
            
            // Update quality indicator if it exists
            const qualityIndicator = document.querySelector('.quality-indicator');
            if (qualityIndicator) {
                const fpsElement = qualityIndicator.querySelector('[data-fps]') || 
                    (() => {
                        const el = document.createElement('div');
                        el.setAttribute('data-fps', '');
                        el.style.color = '#ffd700';
                        el.style.fontSize = '0.7rem';
                        qualityIndicator.appendChild(el);
                        return el;
                    })();
                fpsElement.textContent = `${fps} FPS`;
            }
        }, 1000);

        // Count frames
        const originalAnimate = animate;
        animate = function() {
            frameCount++;
            originalAnimate();
        };
    </script>
</body>
</html>
